package lacework

import (
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/lacework/go-sdk/api"
)

func resourceLaceworkVulnerabilityExceptionContainer() *schema.Resource {
	return &schema.Resource{
		Create: resourceLaceworkVulnerabilityExceptionContainerCreate,
		Read:   resourceLaceworkVulnerabilityExceptionContainerRead,
		Update: resourceLaceworkVulnerabilityExceptionContainerUpdate,
		Delete: resourceLaceworkVulnerabilityExceptionContainerDelete,

		Importer: &schema.ResourceImporter{
			State: importLaceworkVulnerabilityContainerException,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The name of the vulnerability exception",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The description of the vulnerability exception",
			},
			"enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "The state of the vulnerability exception",
			},
			"reason": {
				Type:     schema.TypeString,
				Optional: true,
				Description: "List of severities for the vulnerability exception. Valid severities are:" +
					" False Positive, Accepted Risk, Compensating Controls, Fix Pending, Other",
				Elem: &schema.Schema{
					Type: schema.TypeString,
					StateFunc: func(val interface{}) string {
						return strings.TrimSpace(strings.Title(strings.ToLower(val.(string))))
					},
					ValidateFunc: validation.StringInSlice(vulnerabilityExceptionReasonsSlice(), true),
				},
			},
			"vulnerability_criteria": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Required:    true,
				Description: "The vulnerability criteria",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cves": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of cves",
						},
						"package": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "The list of packages",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Description: "The name of the package",
										Required:    true,
									},

									"version": {
										Type:        schema.TypeString,
										Description: "The version of the package",
										Required:    true,
									},
								},
							},
						},
						"severities": {
							Type:     schema.TypeList,
							Optional: true,
							Description: "List of severities for the vulnerability exception. Valid severities are:" +
								" Critical, High, Medium, Low, Info",
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(strings.Title(strings.ToLower(val.(string))))
								},
								ValidateFunc: func(value interface{}, key string) ([]string, []error) {
									switch strings.ToLower(value.(string)) {
									case "critical", "high", "medium", "low", "info":
										return nil, nil
									default:
										return nil, []error{
											fmt.Errorf(
												"%s: can only be 'Critical', 'High', 'Medium', 'Low', 'Info'", key,
											),
										}
									}
								},
							},
						},
						"fixable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "The state of the vulnerability exception",
						},
					},
				},
			},
			"resource_scope": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "The resource scope",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"image_ids": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of image ids",
						},
						"image_tags": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of image tags",
						},
						"registries": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of registries",
						},
						"repositories": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of repositories",
						},
						"namespaces": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of namespaces",
						},
					},
				},
			},
			"guid": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"created_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"updated_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"created_by": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"updated_by": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"type": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func resourceLaceworkVulnerabilityExceptionContainerCreate(d *schema.ResourceData, meta interface{}) error {
	var (
		lacework   = meta.(*api.Client)
		severities = castAttributeToStringSlice(d, "vulnerability_criteria.0.severities")
		packages   = castAttributeToArrayOfCustomKeyValueMap(d, "vulnerability_criteria.0.package", "name", "version")
	)

	vulnException := api.NewVulnerabilityException(d.Get("name").(string),
		api.VulnerabilityExceptionConfig{
			Description:     d.Get("description").(string),
			Type:            api.VulnerabilityExceptionTypeContainer,
			ExceptionReason: api.NewVulnerabilityExceptionReason(d.Get("reason").(string)),
			Severities:      api.NewVulnerabilityExceptionSeverities(severities),
			Cve:             castAttributeToStringSlice(d, "vulnerability_criteria.0.cves"),
			Package:         api.NewVulnerabilityExceptionPackages(packages),
			Fixable:         d.Get("vulnerability_criteria.0.fixable").(bool),
			ResourceScope: api.VulnerabilityExceptionContainerResourceScope{
				ImageID:    castAttributeToStringSlice(d, "resource_scope.0.image_ids"),
				ImageTag:   castAttributeToStringSlice(d, "resource_scope.0.image_tags"),
				Registry:   castAttributeToStringSlice(d, "resource_scope.0.registries"),
				Repository: castAttributeToStringSlice(d, "resource_scope.0.repositories"),
				Namespace:  castAttributeToStringSlice(d, "resource_scope.0.namespaces"),
			},
		},
	)

	if !d.Get("enabled").(bool) {
		vulnException.Enabled = 0
	}

	log.Printf("[INFO] Creating vulnerability exception with data:\n%+v\n", vulnException)
	response, err := lacework.V2.VulnerabilityExceptions.CreateVulnerabilityExceptionsContainer(vulnException)
	if err != nil {
		return err
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	log.Printf("[INFO] Created vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionContainerRead(d *schema.ResourceData, meta interface{}) error {
	var (
		lacework = meta.(*api.Client)
		response api.VulnerabilityExceptionResponse
	)

	log.Printf("[INFO] Reading vulnerability exception with guid %s\n", d.Id())
	err := lacework.V2.VulnerabilityExceptions.Get(d.Id(), &response)
	if err != nil {
		return err
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("description", response.Data.Props.Description)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	resourceScope := make(map[string]interface{})
	resourceScope["namespaces"] = response.Data.ResourceScope.Namespace
	resourceScope["image_ids"] = response.Data.ResourceScope.ImageID
	resourceScope["image_tags"] = response.Data.ResourceScope.ImageTag
	resourceScope["registries"] = response.Data.ResourceScope.Registry
	resourceScope["repositories"] = response.Data.ResourceScope.Repository
	d.Set("resource_scope", []map[string]interface{}{resourceScope})

	vulnCriteria := make(map[string]interface{})
	vulnCriteria["severities"] = response.Data.VulnerabilityCriteria.Severity
	vulnCriteria["cves"] = response.Data.VulnerabilityCriteria.Cve
	vulnCriteria["package"] = vulnerabilityExceptionFlattenPackages(response.Data.VulnerabilityCriteria.Package)
	vulnCriteria["fixable"] = vulnerabilityExceptionFixableEnabled(response.Data.VulnerabilityCriteria.Fixable)
	d.Set("vulnerability_criteria", []map[string]interface{}{vulnCriteria})
	d.Set("reason", response.Data.ExceptionReason)
	log.Printf("[INFO] Read vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionContainerUpdate(d *schema.ResourceData, meta interface{}) error {
	var (
		lacework   = meta.(*api.Client)
		severities = castAttributeToStringSlice(d, "vulnerability_criteria.0.severities")
		packages   = castAttributeToArrayOfCustomKeyValueMap(d, "vulnerability_criteria.0.package", "name", "version")
	)

	vulnException := api.NewVulnerabilityException(d.Get("name").(string),
		api.VulnerabilityExceptionConfig{
			Description:     d.Get("description").(string),
			Type:            api.VulnerabilityExceptionTypeContainer,
			ExceptionReason: api.NewVulnerabilityExceptionReason(d.Get("reason").(string)),
			Severities:      api.NewVulnerabilityExceptionSeverities(severities),
			Cve:             castAttributeToStringSlice(d, "vulnerability_criteria.0.cves"),
			Package:         api.NewVulnerabilityExceptionPackages(packages),
			Fixable:         d.Get("vulnerability_criteria.0.fixable").(bool),
			ResourceScope: api.VulnerabilityExceptionContainerResourceScope{
				ImageID:    castAttributeToStringSlice(d, "resource_scope.0.image_ids"),
				ImageTag:   castAttributeToStringSlice(d, "resource_scope.0.image_tags"),
				Registry:   castAttributeToStringSlice(d, "resource_scope.0.registries"),
				Repository: castAttributeToStringSlice(d, "resource_scope.0.repositories"),
				Namespace:  castAttributeToStringSlice(d, "resource_scope.0.namespaces"),
			},
		},
	)

	if !d.Get("enabled").(bool) {
		vulnException.Enabled = 0
	}

	log.Printf("[INFO] Updating vulnerability exception with data:\n%+v\n", vulnException)
	response, err := lacework.V2.VulnerabilityExceptions.UpdateVulnerabilityExceptionsContainer(vulnException, d.Id())
	if err != nil {
		return err
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	log.Printf("[INFO] Updated vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionContainerDelete(d *schema.ResourceData, meta interface{}) error {
	lacework := meta.(*api.Client)

	log.Printf("[INFO] Deleting vulnerability exception with guid %s\n", d.Id())
	err := lacework.V2.VulnerabilityExceptions.Delete(d.Id())
	if err != nil {
		return err
	}

	log.Printf("[INFO] Deleted vulnerability exception with guid %s\n", d.Id())
	return nil
}

func importLaceworkVulnerabilityContainerException(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	lacework := meta.(*api.Client)

	log.Printf("[INFO] Importing Lacework Vulnerability Exception with guid: %s\n", d.Id())

	response, err := lacework.V2.VulnerabilityExceptions.GetVulnerabilityExceptionsContainer(d.Id())
	if err != nil {
		return nil, fmt.Errorf(
			"unable to import Lacework resource. Vulnerability Exception with guid '%s' was not found",
			d.Id(),
		)
	}
	log.Printf("[INFO] Vulnerability Exception found with guid: %s\n", response.Data.Guid)
	return []*schema.ResourceData{d}, nil
}

func vulnerabilityExceptionReasonsSlice() []string {
	var reasons []string
	for _, value := range api.VulnerabilityExceptionReasons {
		reasons = append(reasons, value)
	}
	return reasons
}

func vulnerabilityExceptionFixableEnabled(fixable []int) bool {
	return fixable[0] == 1
}

func vulnerabilityExceptionFlattenPackages(vulnPackage []map[string][]string) []map[string]string {
	var packages []map[string]string
	for _, m := range vulnPackage {
		for k, v := range m {
			for _, version := range v {
				packages = append(packages, map[string]string{"name": k, "version": version})
			}
		}
	}
	return packages
}
