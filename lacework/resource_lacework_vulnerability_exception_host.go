package lacework

import (
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/lacework/go-sdk/api"
	"github.com/pkg/errors"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func resourceLaceworkVulnerabilityExceptionHost() *schema.Resource {
	return &schema.Resource{
		Create: resourceLaceworkVulnerabilityExceptionHostCreate,
		Read:   resourceLaceworkVulnerabilityExceptionHostRead,
		Update: resourceLaceworkVulnerabilityExceptionHostUpdate,
		Delete: resourceLaceworkVulnerabilityExceptionHostDelete,

		Importer: &schema.ResourceImporter{
			State: importLaceworkVulnerabilityHostException,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "The name of the vulnerability exception",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "The description of the vulnerability exception",
			},
			"expiry": {
				Type:             schema.TypeString,
				Optional:         true,
				Description:      "The expiration date of the vulnerability exception",
				ValidateDiagFunc: ValidateTimeFormat(time.RFC3339),
			},
			"enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "The state of the vulnerability exception",
			},
			"reason": {
				Type:     schema.TypeString,
				Optional: true,
				Description: fmt.Sprintf(
					"List of severities for the vulnerability exception. Valid severities are: %v",
					vulnerabilityExceptionReasonsSlice()),
				Elem: &schema.Schema{
					Type: schema.TypeString,
					StateFunc: func(val interface{}) string {
						return strings.TrimSpace(cases.Title(language.English).String(strings.ToLower(val.(string))))
					},
				},
				ValidateFunc: validation.StringInSlice(vulnerabilityExceptionReasonsSlice(), true),
			},
			"vulnerability_criteria": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Required:    true,
				Description: "The vulnerability criteria",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"cves": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of cves",
						},
						"package": {
							Type:        schema.TypeSet,
							Optional:    true,
							Description: "The list of packages",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Description: "The name of the package",
										Required:    true,
									},

									"version": {
										Type:        schema.TypeString,
										Description: "The version of the package",
										Required:    true,
									},
								},
							},
						},
						"severities": {
							Type:     schema.TypeList,
							Optional: true,
							Description: "List of severities for the vulnerability exception. Valid severities are:" +
								" Critical, High, Medium, Low, Info",
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(cases.Title(language.English).String(strings.ToLower(val.(string))))
								},
								ValidateFunc: func(value interface{}, key string) ([]string, []error) {
									switch strings.ToLower(value.(string)) {
									case "critical", "high", "medium", "low", "info":
										return nil, nil
									default:
										return nil, []error{
											fmt.Errorf(
												"%s: can only be 'Critical', 'High', 'Medium', 'Low', 'Info'", key,
											),
										}
									}
								},
							},
						},
						"fixable": {
							Type:        schema.TypeBool,
							Optional:    true,
							Description: "The state of the vulnerability exception",
						},
					},
				},
			},
			"resource_scope": {
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Description: "The resource scope",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hostnames": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of hostnames",
						},
						"cluster_names": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of cluster names",
						},
						"external_ips": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of external ips",
						},
						"namespaces": {
							Type:     schema.TypeList,
							Optional: true,
							Elem: &schema.Schema{
								Type: schema.TypeString,
								StateFunc: func(val interface{}) string {
									return strings.TrimSpace(val.(string))
								},
							},
							Description: "The list of namespaces",
						},
					},
				},
			},
			"guid": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"created_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"updated_time": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"created_by": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"updated_by": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"type": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func resourceLaceworkVulnerabilityExceptionHostCreate(d *schema.ResourceData, meta interface{}) (err error) {
	var (
		lacework   = meta.(*api.Client)
		severities = castAttributeToStringSlice(d, "vulnerability_criteria.0.severities")
		packages   = castAttributeToArrayOfCustomKeyValueMap(d, "vulnerability_criteria.0.package", "name", "version")
		expiryTime time.Time
		vulnExCfg  = api.VulnerabilityExceptionConfig{
			Description:     d.Get("description").(string),
			Type:            api.VulnerabilityExceptionTypeHost,
			ExceptionReason: api.NewVulnerabilityExceptionReason(d.Get("reason").(string)),
			Severities:      api.NewVulnerabilityExceptionSeverities(severities),
			Cve:             castAttributeToStringSlice(d, "vulnerability_criteria.0.cves"),
			Package:         api.NewVulnerabilityExceptionPackages(packages),
			Fixable:         d.Get("vulnerability_criteria.0.fixable").(bool),
		}
	)
	if d.Get("expiry") != nil {
		expiryTime, err = time.Parse(time.RFC3339, d.Get("expiry").(string))
		if err != nil {
			return errors.Wrap(err, fmt.Sprintf("unable to parse expiryTime %s", d.Get("expiry").(string)))
		}
	}
	vulnExCfg.ExpiryTime = expiryTime

	if len(d.Get("resource_scope").([]interface{})) > 0 {
		vulnExCfg.ResourceScope = api.VulnerabilityExceptionHostResourceScope{
			Hostname:    castAttributeToStringSlice(d, "resource_scope.0.hostnames"),
			ExternalIP:  castAttributeToStringSlice(d, "resource_scope.0.external_ips"),
			ClusterName: castAttributeToStringSlice(d, "resource_scope.0.cluster_names"),
			Namespace:   castAttributeToStringSlice(d, "resource_scope.0.namespaces"),
		}
	}

	vulnException := api.NewVulnerabilityException(d.Get("name").(string), vulnExCfg)

	if !d.Get("enabled").(bool) {
		vulnException.Enabled = 0
	}

	log.Printf("[INFO] Creating vulnerability exception with data:\n%+v\n", vulnException)
	response, err := lacework.V2.VulnerabilityExceptions.Create(vulnException)
	if err != nil {
		return err
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	log.Printf("[INFO] Created vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionHostRead(d *schema.ResourceData, meta interface{}) error {
	var (
		lacework = meta.(*api.Client)
	)

	log.Printf("[INFO] Reading vulnerability exception with guid %s\n", d.Id())
	response, err := lacework.V2.VulnerabilityExceptions.GetVulnerabilityExceptionsHost(d.Id())
	if err != nil {
		return resourceNotFound(d, err)
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("description", response.Data.Props.Description)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	if d.Get("expiry") != nil {
		expiryTime, err := time.Parse(time.RFC3339, d.Get("expiry").(string))
		if err != nil {
			return errors.Wrap(err, fmt.Sprintf("unable to parse expiryTime %s", d.Get("expiry").(string)))
		}
		d.Set("expiry", expiryTime)
	}

	if len(d.Get("resource_scope").([]interface{})) > 0 {
		resourceScope := make(map[string]interface{})
		resourceScope["namespaces"] = response.Data.ResourceScope.Namespace
		resourceScope["hostnames"] = response.Data.ResourceScope.Hostname
		resourceScope["external_ips"] = response.Data.ResourceScope.ExternalIP
		resourceScope["cluster_names"] = response.Data.ResourceScope.ClusterName
		d.Set("resource_scope", []map[string]interface{}{resourceScope})
	}

	vulnCriteria := make(map[string]interface{})
	vulnCriteria["severities"] = response.Data.VulnerabilityCriteria.Severity
	vulnCriteria["cves"] = response.Data.VulnerabilityCriteria.Cve
	vulnCriteria["package"] = vulnerabilityExceptionFlattenPackages(response.Data.VulnerabilityCriteria.Package)
	vulnCriteria["fixable"] = vulnerabilityExceptionFixableEnabled(response.Data.VulnerabilityCriteria.Fixable)
	d.Set("vulnerability_criteria", []map[string]interface{}{vulnCriteria})

	d.Set("reason", response.Data.ExceptionReason)
	log.Printf("[INFO] Read vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionHostUpdate(d *schema.ResourceData, meta interface{}) (err error) {
	var (
		lacework   = meta.(*api.Client)
		severities = castAttributeToStringSlice(d, "vulnerability_criteria.0.severities")
		packages   = castAttributeToArrayOfCustomKeyValueMap(d, "vulnerability_criteria.0.package", "name", "version")
		expiryTime time.Time

		vulnExCfg = api.VulnerabilityExceptionConfig{
			Description:     d.Get("description").(string),
			Type:            api.VulnerabilityExceptionTypeHost,
			ExceptionReason: api.NewVulnerabilityExceptionReason(d.Get("reason").(string)),
			Severities:      api.NewVulnerabilityExceptionSeverities(severities),
			Cve:             castAttributeToStringSlice(d, "vulnerability_criteria.0.cves"),
			Package:         api.NewVulnerabilityExceptionPackages(packages),
			Fixable:         d.Get("vulnerability_criteria.0.fixable").(bool),
		}
	)

	if d.Get("expiry") != nil {
		expiryTime, err = time.Parse(time.RFC3339, d.Get("expiry").(string))
		if err != nil {
			return errors.Wrap(err, fmt.Sprintf("unable to parse expiryTime %s", d.Get("expiry").(string)))
		}
	}
	vulnExCfg.ExpiryTime = expiryTime

	if len(d.Get("resource_scope").([]interface{})) > 0 {
		vulnExCfg.ResourceScope = api.VulnerabilityExceptionHostResourceScope{
			Hostname:    castAttributeToStringSlice(d, "resource_scope.0.hostnames"),
			ExternalIP:  castAttributeToStringSlice(d, "resource_scope.0.external_ips"),
			ClusterName: castAttributeToStringSlice(d, "resource_scope.0.cluster_names"),
			Namespace:   castAttributeToStringSlice(d, "resource_scope.0.namespaces"),
		}
	}

	vulnException := api.NewVulnerabilityException(d.Get("name").(string), vulnExCfg)

	if !d.Get("enabled").(bool) {
		vulnException.Enabled = 0
	}

	log.Printf("[INFO] Updating vulnerability exception with data:\n%+v\n", vulnException)
	response, err := lacework.V2.VulnerabilityExceptions.UpdateVulnerabilityExceptionsHost(vulnException, d.Id())
	if err != nil {
		return err
	}

	d.SetId(response.Data.Guid)
	d.Set("name", response.Data.ExceptionName)
	d.Set("guid", response.Data.Guid)
	d.Set("enabled", response.Data.Enabled == 1)
	d.Set("created_time", response.Data.CreatedTime)
	d.Set("updated_time", response.Data.UpdatedTime)
	d.Set("created_by", response.Data.Props.CreatedBy)
	d.Set("updated_by", response.Data.Props.UpdatedBy)
	d.Set("type", response.Data.ExceptionType)

	log.Printf("[INFO] Updated vulnerability exception with guid %s\n", response.Data.Guid)
	return nil
}

func resourceLaceworkVulnerabilityExceptionHostDelete(d *schema.ResourceData, meta interface{}) error {
	lacework := meta.(*api.Client)

	log.Printf("[INFO] Deleting vulnerability exception with guid %s\n", d.Id())
	err := lacework.V2.VulnerabilityExceptions.Delete(d.Id())
	if err != nil {
		return err
	}

	log.Printf("[INFO] Deleted vulnerability exception with guid %s\n", d.Id())
	return nil
}

func importLaceworkVulnerabilityHostException(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	lacework := meta.(*api.Client)

	log.Printf("[INFO] Importing Lacework Vulnerability Exception with guid: %s\n", d.Id())

	response, err := lacework.V2.VulnerabilityExceptions.GetVulnerabilityExceptionsHost(d.Id())

	if err != nil {
		return nil, fmt.Errorf(
			"unable to import Lacework resource. Vulnerability Exception with guid '%s' was not found",
			d.Id(),
		)
	}
	log.Printf("[INFO] Vulnerability Exception found with guid: %s\n", response.Data.Guid)
	return []*schema.ResourceData{d}, nil
}
